/*
    3D Math Library for the Arduino Platform
	Quat and vector datatypes and functions
    by Phillip Schmidt
    Dec 2013
    v0.1.0 - beta
	
	Quat = w, x, y, z (float)
	Vec3 = x, y, z (float)
	
	
	(matrix3 = 3x3 matrix - implement later... maybe...)
	(matrix4 = 4x4 matrix - implement later... maybe...)
	
	
*/
 
#ifndef MATH3D_h
#define MATH3D_h
 
#include "Arduino.h"
 
 
class Quat
{
	public:
    float w, x, y, z;	
	
	Quat();
	Quat(float, float, float, float);
	
	//~Quat();
	
	Quat& operator+=(const Quat&);
	Quat& operator+(const Quat&) const;
	Quat operator*(const Quat&) const;
	
	friend Quat operator*(Quat);

	
};

Quat::Quat(float a, float b, float c, float d)
{
	w = a;
	x = b;
	y = c;
	z = d;
}

Quat::Quat()
{
	w = 1.0;
	x = 0.0;
	y = 0.0;
	z = 0.0;
}

class Vec3
{
	public:
    float x, y, z;	
	
	Vec3();
	Vec3(float, float, float);
	
	//~Vec3();
	
	Vec3& operator+=(const Vec3&);
	Vec3& operator+(const Vec3&) const;
	Vec3& operator-=(const Vec3&);
	Vec3& operator-(const Vec3&) const;
	Vec3 operator*(const Vec3&) const;
	
	Vec3 operator=(const Quat&);
	friend Vec3 operator*(Vec3);
	
};

Vec3::Vec3(float a, float b, float c)
{
	x = a;
	y = b;
	z = c;
}

Vec3::Vec3()
{
	x = 0;
	y = 0;
	z = 0;
}

inline Quat & Quat::operator+=(const Quat& b)
{
	Quat& a = *this;
	a.w += b.w;
	a.x += b.x;
	a.y += b.y;
	a.z += b.z;
	return *this;
}

inline Quat & Quat::operator+(const Quat& b) const
{
	Quat a = *this;
	a += b;
	return a;
}

inline Quat Quat::operator*(const Quat& rhs) const // multiply: quat * quat
{
	Quat lhs = *this;	// 
	Quat a;
	a.x = lhs.w * rhs.x + lhs.z * rhs.y - lhs.y * rhs.z + lhs.x * rhs.w;  
	a.y = lhs.w * rhs.y + lhs.x * rhs.z + lhs.y * rhs.w - lhs.z * rhs.x;
	a.z = lhs.y * rhs.x - lhs.x * rhs.y + lhs.w * rhs.z + lhs.z * rhs.w;
	a.w = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
	// 16 mult, 6 add, 6 sub
	return a;
}

inline Quat qConj(Quat a)
{
	a.w = a.w;
	a.x = -a.x;
	a.y = -a.y;
	a.z = -a.z;
	return a;
}

inline Quat v2q(const Vec3& a)	// Vec3 to Quat
{
    Quat b;
    b.w = 0.0;
    b.x = a.x;
    b.y = a.y;
    b.z = a.z;
    return(b);
}

inline Vec3 q2v(const Quat& a)	// Quat to Vec3
{
	Vec3 b;
    b.x = a.x;
    b.y = a.y;
    b.z = a.z;
    return(b);
}

inline Vec3 Vec3::operator=(const Quat& b)
{
	Vec3& a = *this;
	a.x = b.x;
	a.y = b.y;
	a.z = b.z;
	return *this;
}

inline Quat operator*(const Quat& a, const Vec3& b) // multiply: quat * vec3
{
	return a * v2q(b);
}

inline Quat operator*(const Vec3& a, const Quat& b) // multiply: vec3 * quat
{
	return v2q(a) * b;
}

inline Quat operator*=(Quat& a, float b) // multiply: quat * float
{
	a.w *= b;
	a.x *= b;
	a.y *= b;
	a.z *= b;
	return a;
}

inline Quat operator*(Quat a, float b) // multiply: quat * float
{
	return a *= b;
}

inline Quat operator*(float b, Quat a) // multiply: float * quat
{
	return a *= b;
}

inline Vec3 & Vec3::operator+=(const Vec3& b)
{
	Vec3& a = *this;
	a.x += b.x;
	a.y += b.y;
	a.z += b.z;
	return *this;
}

inline Vec3 & Vec3::operator+(const Vec3& b) const
{
	Vec3 a = *this;
	return a += b;
}

inline Vec3 & Vec3::operator-=(const Vec3& b)
{
	Vec3& a = *this;
	a.x -= b.x;
	a.y -= b.y;
	a.z -= b.z;
	return *this;
}

inline Vec3 & Vec3::operator-(const Vec3& b) const
{
	Vec3 a = *this;
	return a -= b;
}

inline Vec3 operator*=(Vec3& a, float b) // multiply: vec3 * float
{
	a.x *= b;
	a.y *= b;
	a.z *= b;
	return a;
}

inline Vec3 operator*(Vec3 a, float b) // multiply: vec3 * float
{
	return a *= b;
}

inline Vec3 operator*(float b, Vec3 a) // multiply: float * vec3
{
	return a *= b;
}


inline Vec3 Vec3::operator*(const Vec3& R) const // cross product of 3d vectors
{ 
    Vec3 L = *this;
	Vec3 a(	L.y * R.z - L.z * R.y,
					L.z * R.x - L.x * R.z,
					L.x * R.y - L.y * R.x);
    return a;
}

inline Quat incQuat(const Vec3& w, const unsigned long& t){  // (angular vel vector[rad/s], time interval[us])
	float dT_2 = float(t) * 0.0000005; // time in seconds & divided in half for theta/2 computations

	Quat a;
	a.x = w.x * dT_2;
 	a.y = w.y * dT_2;
	a.z = w.z * dT_2;
	a.w = 1.0 - 0.5 * (a.x * a.x + a.y * a.y + a.z * a.z);// optimization by Stefan Atev
	
	return a;
}

inline Vec3 grav2sc(const Quat& q){ // translate inertial 0,0,1 to spacecraft frame 
	Vec3 a;
	
	// Optimized form of Q Vg Q*
	a.x = 2.0 * q.x * q.z - 2.0 * q.y * q.w;  // factoring is 8us slower...
	a.y = 2.0 * q.y * q.z + 2.0 * q.x * q.w;
	a.z = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;
	//a.w = 0;
	
	return a;
}


inline Vec3 magComp(const Quat& q, const Vec3& m ){ // translate mag to inertial frame, compute compensation, translate back to sc frame

	Vec3 a = q2v(q * m * qConj(q)); // translate mag reading to inertial frame
	
	const Vec3 north(1.0, 0.0, 0.0);
	
	a = north * a; // cross product to produce error correction rotation 
	a.x = 0;	// eliminate rotation around x to avoid conflict with accelerometer compensation
	a.y = 0;	// eliminate rotation around y...
	
/*	a.x = 0;
	a.y = 0;
	a.z = L.x * R.y - L.y * R.x;  */  //- future optimization to replace the above 3 lines once order of operations is confirmed
	
	a = q2v(qConj(q) * a * q);	// translate back to sc frame - future: optimize based on inputs of x=0 and y=0 
	
	return a;
}

inline float mag(const Quat& a){
	return sqrt(a.w*a.w + a.x*a.x + a.y*a.y + a.z*a.z);
}

inline float mag(const Vec3& a){
	return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

inline float InvSqrt (float x){ // the "Quake" inverse square root -- 
	union{  
		int32_t i;  
		float    f; 
	} conv; 
	conv.f = x; 
	conv.i = 0x5f3759df - (conv.i >> 1); 
	return 0.5f * conv.f * (3.0f - x * conv.f * conv.f); //
}

inline Vec3 normalize(const Vec3& a){
	return a * InvSqrt (a.x*a.x + a.y*a.y + a.z*a.z);
}

inline Quat normalize(const Quat& a){
	return a * InvSqrt (a.x*a.x + a.y*a.y + a.z*a.z + a.w*a.w);
}


#endif 
