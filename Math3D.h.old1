/*
    3D Math Library for the Arduino Platform
	Quaternion and vector datatypes and functions
    by Phillip Schmidt
    July 2014
    v1.1.0
	
	STRUCTURES
		Quat - x, y, z, w
		Vec3 - x, y, z
		
		
	BASIC OPERATIONS
		Quat QuatMultiply(Quat, Quat)			// combine rotations encoded in quaternion form
		Quat QuatMultiply(Quat, Vec3) 		//	used during vector translation
		Quat QuatConj(Quat)						// represents a rotation opposite of the original
		Quat Vector2Quat(Vec3)					// convert a 3D vector to a quaternion (add component w=0)
		Quat QuatScale(Quat, float)			// multiply a quaternion be a scaler
		
		Vec3 Quat2Vector(Quat)					// convert a quaternion to a 3D vector (truncate w component)
		Vec3 VecScale(Vec3, float)				// multiply a 3D vector by a scaler
		Vec3 VecAdd(Vec3, Vec3) 				// sum the components of two 3D vectors
		Vec3 VecDiff(Vec3, Vec3) 				// subtract the components of two vectors
		Vec3 VecCross(Vec3, Vec3) 			// cross product of two vectors

		
	COMPOUND OPERATIONS
		float InvSqrt (float)						// fast inverse square root using
		float Magnitude(Quat)						// quaternion magnitude
		float Magnitude(Vec3)						// 3D vector magnitude
		Vec3 Normalize(Vec3)					// 3D vector normalize
		Quat Normalize(Quat)						// quaternion normalize
		
		
	SPECIAL FUNCTIONS
		Vec3 Vec2Vehicle(Quat, Vec3)		// translate a 3D vector from the inertial frame to the vehicle frame
		Vec3 Vec2Inertial(Quat, Vec3)		// translate a 3D vector from the vehicle frame to the inertial frame
		Quat QuatIntegrate(Quat, Vec3, unsigned long)	// use the current orientation quaternion, 3D rotation rate vector, and time interval to compute the current orientation
		Vec3 AccelComp(Quat, Vec3)			// compute a 3D vector that describes the rotation required to correct the discrepancy between estimated vertical and the gravitational vertical
		Vec3 MagComp(Quat, Vec3)			// compute a 3D vector that describes the rotation required to correct the discrepancy between estimated north and the magnetic north
	
*/
 
#ifndef MATH3D_h
#define MATH3D_h
 
#include "Arduino.h"
 
 
 
// =========================
// 			STRUCTURES
// =========================

struct Quat
{
	float x = 0.0f;
	float y = 0.0f;
	float z = 0.0f;
	float w = 1.0f;
};

struct Vec3
{
	float x = 0.0f;
	float y = 0.0f;
	float z = 0.0f;
};



// =========================
// 			BASIC OPERATIONS 
// =========================

inline Quat QuatMultiply(const Quat& lhs, const Quat& rhs) // Quat * Quat --16 mult, 6 add, 6 sub  (266us)
{
	Quat a;
	a.x = lhs.w * rhs.x + lhs.z * rhs.y - lhs.y * rhs.z + lhs.x * rhs.w;  
	a.y = lhs.w * rhs.y + lhs.x * rhs.z + lhs.y * rhs.w - lhs.z * rhs.x;
	a.z = lhs.y * rhs.x - lhs.x * rhs.y + lhs.w * rhs.z + lhs.z * rhs.w;
	a.w = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
	return a;
}

inline Quat QuatMultiply(const Quat& lhs, const Vec3& rhs) // Quat * Vec3 --12 mult, 3 add, 6 sub  (190us)
{
	Quat a;
	a.x =  lhs.w * rhs.x + lhs.z * rhs.y - lhs.y * rhs.z;  
	a.y =  lhs.w * rhs.y + lhs.x * rhs.z - lhs.z * rhs.x;
	a.z =  lhs.y * rhs.x - lhs.x * rhs.y + lhs.w * rhs.z;
	a.w = -lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
	return a;
}

inline Quat QuatConj(Quat a)
{
	//a.w = a.w;
	a.x = -a.x;
	a.y = -a.y;
	a.z = -a.z;
	return a;
}

inline Quat Vector2Quat(const Vec3& a)	// Vec3 to Quat
{
    Quat b;
    b.w = 0.0;
    b.x = a.x;
    b.y = a.y;
    b.z = a.z;
    return(b);
}

inline Vec3 Quat2Vector(const Quat& a)	// Quat to Vec3
{
	Vec3 b;
    b.x = a.x;
    b.y = a.y;
    b.z = a.z;
    return(b);
}

inline Quat QuatScale(Quat a, const float& b) // multiply: quat * float
{
	a.w *= b;
	a.x *= b;
	a.y *= b;
	a.z *= b;
	return a;
}

inline Vec3 VecScale(Vec3 a, const float& b) // multiply: vec3 * float
{
	a.x *= b;
	a.y *= b;
	a.z *= b;
	return a;
}

inline Vec3 VecAdd(Vec3 a, const Vec3& b) // add: vec3 + vec3
{
	a.x += b.x;
	a.y += b.y;
	a.z += b.z;
	return a;
}

inline Vec3 VecDiff(Vec3 a, const Vec3& b) // subtract: vec3 - vec3
{
	a.x -= b.x;
	a.y -= b.y;
	a.z -= b.z;
	return a;
}

inline Vec3 VecCross(const Vec3& L, const Vec3& R) // cross product of 3d vectors
{ 
	Vec3 a;
	a.x = L.y * R.z - L.z * R.y;
	a.y = L.z * R.x - L.x * R.z;
	a.z = L.x * R.y - L.y * R.x;
    return a;
}



// =========================
//		COMPOUND OPERATIONS
// =========================

inline float InvSqrt (float x){ // the "Quake" inverse square root -- 
	union{  
		int32_t i;  
		float    f; 
	} conv; 
	conv.f = x; 
	conv.i = 0x5f3759df - (conv.i >> 1); 
	return 0.5f * conv.f * (3.0f - x * conv.f * conv.f); //
}

inline float Magnitude(const Quat& a){
	return sqrt(a.w*a.w + a.x*a.x + a.y*a.y + a.z*a.z);
}

inline float Magnitude(const Vec3& a){
	return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

inline Vec3 Normalize(const Vec3& a){
	return VecScale(a, InvSqrt (a.x*a.x + a.y*a.y + a.z*a.z));
}

inline Quat Normalize(const Quat& a){
	return QuatScale(a, InvSqrt (a.x*a.x + a.y*a.y + a.z*a.z + a.w*a.w));
}



// =========================
//		SPECIAL FUNCTIONS 
// =========================

inline Vec3 Vec2Vehicle(const Quat& q, Vec3 v){	

	Vec3 r;										// v + 2*r X (r X V + q.w*v)
	r.x = q.x;
	r.y = q.y;
	r.z = q.z;
	
	return v + VecCross(r + r, VecCross(r, v) + VecScale(v, q.w));	// 15mult + 12add 
	
	/*
	Quat a;													// Q V Q*
	a.x =  q.w * v.x + q.z * v.y - q.y * v.z;  				// a = Q V
	a.y =  q.w * v.y + q.x * v.z - q.z * v.x;
	a.z =  q.y * v.x - q.x * v.y + q.w * v.z;
	a.w = -q.x * v.x - q.y * v.y - q.z * v.z;
	
	v.x =  a.x * q.w - a.z * q.y + a.y * q.z - a.w * q.x;	// v = a Q*
	v.y =  a.z * q.x - a.x * q.z + a.y * q.w - a.w * q.y;
	v.z =  a.z * q.w - a.y * q.x + a.x * q.y - a.w * q.z;
	return v;
	*/
	
	//return Quat2Vector(QuatMultiply(QuatMultiply(q, v), QuatConj(q))); 
}

inline Vec3 Vec2Inertial(const Quat& q, Vec3 v){	

	Vec3 r;										// v + 2*r X (r X V + q.w*v)
	r.x = -q.x;
	r.y = -q.y;
	r.z = -q.z;
	
	return v + VecCross(r + r, VecCross(r, v) + VecScale(v, q.w)); // 15mult + 15add 

	/*
	Quat a;													// Q* V Q
	a.x = q.y * v.z - q.w * v.x - q.z * v.y;  				// a = Q* V
	a.y = q.z * v.x - q.w * v.y - q.x * v.z;
	a.z = q.x * v.y - q.w * v.z - q.y * v.x;
	a.w = q.x * v.x + q.y * v.y + q.z * v.z;
	
	v.x = a.w * q.x + a.z * q.y - a.y * q.z + a.x * q.w;	// v = a Q
	v.y = a.w * q.y + a.x * q.z + a.y * q.w - a.z * q.x;
	v.z = a.y * q.x - a.x * q.y + a.w * q.z + a.z * q.w;
	return v;
	*/

	//return Quat2Vector(QuatMultiply(QuatMultiply(QuatConj(q), v), q)); 
}

inline Quat QuatIntegrate(const Quat& q, const Vec3& w, const unsigned long& t){  // (orientation quat, angular vel vector[rad/s], time interval[us])
	float dT_2 = float(t) * 0.0000005; // time in seconds & divided in half for theta/2 computations
	Quat a;
	a.x = w.x * dT_2;
 	a.y = w.y * dT_2;
	a.z = w.z * dT_2;
	a.w = 1.0 - 0.5 * (a.x * a.x + a.y * a.y + a.z * a.z);
	return QuatMultiply(a, q);	// time = 116us + mult = 362us		(REF: RotMatrix = 588us)
}

inline Quat QuatRotation(const Quat& q, const Vec3& w, const unsigned long& t){  // (orientation quat, angular vel vector[rad/s], time interval[us])
	// large rotation quaternion
	
	float vMag = Magnitude(w);
	float theta_2 = vMag * float(t) * 0.0000005;	// rotation angle divided by 2
	float Sin_Mag = sinf(theta_2) / vMag;			// computation minimization
	
	Quat a;
	a.x = w.x * Sin_Mag;
 	a.y = w.y * Sin_Mag;
	a.z = w.z * Sin_Mag;
	a.w = cosf(theta_2);
	return QuatMultiply(a, q);		// time = 390us + mult  = 636
}

inline Vec3 AccelComp(const Quat& q, const Vec3& a){ // translate inertial 0,0,1 to spacecraft frame, and take the cross product with the accel reading to determine error correction vector
	Vec3 b;
	// Optimized form of Q Vg Q*
	b.x = 2.0 * q.x * q.z - 2.0 * q.y * q.w;  // factoring is 8us slower... not sure why
	b.y = 2.0 * q.y * q.z + 2.0 * q.x * q.w;
	b.z = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;
	//a.w = 0;
	return VecCross(a, b);
}

inline Vec3 MagComp(const Quat& q, const Vec3& m ){ // translate mag vector to inertial frame, compute compensation, translate back to vehicle frame
	// Q* Vm Q ==> translate mag reading to inertial frame
	//Vec3 a = Quat2Vector(QuatMultiply(QuatMultiply(QuatConj(q), m), q));
	//a.z = 0; // eliminate z component
	Quat a;	// scratch temp quaternion variable
	a.x = q.w * m.x - q.z * m.y + q.y * m.z;  // Q* Vm
	a.y = q.w * m.y - q.x * m.z + q.z * m.x;
	a.z = q.x * m.y + q.w * m.z - q.y * m.x;
	a.w = q.x * m.x + q.y * m.y + q.z * m.z;
	
	Vec3 b;  // scratch temp vector variable
	b.x = a.w * q.x + a.z * q.y - a.y * q.z + a.x * q.w;  // a Q
	b.y = a.w * q.y + a.x * q.z + a.y * q.w - a.z * q.x;
	b.z = 0.0f; //a.y * q.x - a.x * q.y + a.w * q.z + a.z * q.w; // eliminate Z component due to Mag field inclination
	//b.w = a.w * q.w - a.x * q.x - a.y * q.y - a.z * q.z;	// shown for reference

	b = Normalize(b);
	
	//Vec3 north;
	//north.x = 1.0f;
	
	//b = VecCross(b,  north); // cross product to produce error correction rotation 
	//b.x = 0;	// eliminate rotation around x to avoid conflict with accelerometer compensation
	//b.y = 0;	// eliminate rotation around y...
	
	//float b_z = -b.y; // simplified z component of b cross North (this is rolled into the next operation already)
	//b = Quat2Vector(QuatMultiply(a, QuatConj(q)));	// translate back to sc frame
	a.x =  q.y * b.y;  // Q Vcomp Q* ==> translate compensation back to vehicle frame
	a.y = -q.x * b.y;
	a.z = -q.w * b.y;
	a.w =  q.z * b.y;	
	
	b.x = a.y * q.z + a.x * q.w - a.w * q.x - a.z * q.y;  
	b.y = a.y * q.w + a.z * q.x - a.w * q.y - a.x * q.z;
	b.z = a.x * q.y - a.w * q.z + a.z * q.w - a.y * q.x;
	//b.w =  a.w * q.w + a.x * q.x + a.y * q.y + a.z * q.z; // (not needed since 3D vector is returned)
	
	return b;
}


#endif 
